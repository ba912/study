# 2장: 의미있는 이름

### 들어가면서
변수, 함수, 인수, 클래스, 패키지, 소스파일, 디렉터리, jar, war등<br>
소프트웨어에서 이름은 여러곳에 쓰이기 때문에 이름을 잘 지어놓으면 여러모로 편하다. <br>
이 장에서는 이름을 잘 짓는 간단한 규칙을 소개한다.
<br><br><br>

### #1 의도를 분명히 밝혀라
의도가 분명한 이름은 정말로 중요하다. <br>
좋은 이름을 짓는건 시간이 걸리지만, 좋은 이름으로 절약하는 시간이 훨씬 더 많다.<br>


```
> Code1

int d; //경과시간(단위: 날짜)
```


```
> Code2

int elapsedTimeInDays;
int daySinceCreation;
int daySinceModification;
int fileAgeInDays;
```

`code1` 처럼 아무의미가 없는 변수명이라면 주석으로 설명해야한다. <br>
하지만 `code2` 처럼 의도가 드러나는 이름을 사용하면 코드 이해와 변경이 쉬워진다.


```
> code3

public List<int[]> getThem() {
    List<int[]> list1 = new ArrayList<int[]>();
    for (int[] x: theList) {
      if(x[0] == 4) {
        list1.add(x);
      }
    }
    return list1;
}
```

`code3`은 복잡한 코드가 아니다. <br>
하지만 코드가 하는 일을 짐작하기 어렵다.<br>
<br>
문제는 코드의 단순성이 아니라 코드의 **함축성**이다.<br>
위 코드는 암암리에 독자가 다음과 같은 정보를 안다고 가정한다.

1. theList에 무엇이 들었는가?
2. theList에서 0번째 값이 어째서 중요한가?
3. 값 4는 무슨 의미인가?
4. 함수가 반환하는 리스트 list1을 어떻게 사용하는가?

만약 지뢰찾기 게임을 만든다는 정보가 제공되었고 의도가 분명한 이름을 지어줬다면 이해가 훨씬 쉬웠을 것이다.

```
> code4

public List<Cell> getFlaggedCells() {
    List<Cell> flaggedCells = new ArrayList<Cell>();
    for (Cell cell : gameBoard) {
        if (cell.isFlagged()) {
            flaggedCells.add(cell );
        }
    }
    return flaggedCells;
}
```
단순히 이름만 고쳤는데도 함수가 하는 일을 이해하기가 쉬워졌다.<br>
바로 이것이 좋은 이름이 주는 위력이다.
<br><br><br>
### #2 그릇된 정보를 피하라
프로그래머는 코드에 그릇된 단서를 남겨서는 안된다.<br>
나름대로 널리 쓰이는 의미가 있는 단어를 다른 의미로 사용해도 안된다.
##### e.g.직각삼각형의 빗변(hypotenuse)을 구현할때는 hp가 훌륭한 약어로 보일지라도 hp라는 변수는 독자에게 그릇된 정보를 제공한다.
<br>

```
> code5

int a= l;
if ( O == l);
e1se
l = O1;
```
`code5`에서 소문자L은 숫자1처럼 보이고 대문자O는 숫자0처럼 보인다.<br>
그릇된 정보로 괜스레 일거리를 만들 필요가 없다.

<br><br><br>
### #3 의미 있게 구분하라
컴파일러나 인터프리터만 통과하려는 생각으로 코드를 구현하는 프로그래머는 스스로 문제를 일으킨다.<br>
컴파일러를 통과할지라도 연속된 숫자를 덧붙이거나 noise word를 추가하는 방식은 적절하지 못하다.<br>
```
> code6

public static void copyChars(char a1[], char a2[]) {
    for (int i=0; i < a1.length; i++) {
        a2[i] = a1[i];
    }
}
```

`code6`에서 연속적인 숫자를 덧붙인 이름(a1, a2, ...)은 그릇된 정보를 제공하는 이름도 아니며, 아무런 정보를 제공하지 못하는 이름일 뿐이다. <br>
저자의 의도가 전혀 드러나지 않는다. <br>
함수 인수 이름으로 source와 destination을 사용하면 코드 읽기가 훨씬 더 쉬어질 것이다.
<br><br>
불용어를 추가한 이름역시 아무런 정보도 제공하지 못한다.
```
> code7

getActiveAccount();
getActiveAccountInfo();
getActiveAccountData();
```

`code7`을 보면 프로그래머는 어느 함수를 호출해야하는지 알 수 없다.<br>
명확한 관례가 없다면 읽는 사람이 차이를 알도록 이름을 지어라.
<br><br><br>
### #4 발음하기 쉬운 이름을 사용하라
프로그래밍은 사회활동이다.<br>
발음하기 어려운 이름은 토론하기도 어렵다.<br>

```
> code8

class DtaRcrd102 {
    private Date genymdhms;
    private Date modymdhms;
    private final String pszqint = "102";
}

class Customer {
    private Date generationTimestamp;
    private Date modificationTimestamp;
    private final String recordId = "102";
}
```
`code8`의 첫번째 클래스와 두번째 클래스의 변수명을 말하며 설명한다고 생각해보면 바로 와닿을 것이다.
<br><br><br>
### #5 검색하기 쉬운 이름을 사용하라
> 이름 길이는 범위 크기에 비례해야 한다.

변수나 상수를 코드 여러 곳에서 사용하는 경우라면 검색하기 쉽게 하기 위해 긴 이름이 짧은 이름보다 좋다.<br>
```
> code9

for (int j=0; j < 34; j++) {
    s += (t[j]*4)/5
}
```
```
> code10

int realDaysPerIdealDay = 4;
const int WORK_DAYS_PER_WEEK = 5;
int sum =0;
for (int j=0; j < NUMBER_OF_TASKS; j++) {
    int realTaskDays = taskEstimate[j] * realDaysPerIdealDay;
    int realTaskWeeks = (realTaskDays / WORK_DAYS_PER_WEEK);
    sum += realTaskWeeks;
}
```
위 코드처럼 이름을 의미있게 지으면 함수가 길어진다. 하지만 5에 비해 WORK_DAYS_PER_WEEK를 찾기가 얼마나 쉬운지 생각해보라. 그냥 5를 사용한다면 5가 들어가는 이름을 모두 찾은 후 의미를 분석해 원하는 상수를 가려내야 한다.

<br><br><br>
### #6 인코딩을 피하라
인코딩한 이름은 거의 발음하기 어렵고 오타가 생기기 쉽다.<br>
객체는 강한 타입(strongly-typed)이며, IDE는 코드를 컴파일하지 않고도 타입 오류를 감지할 정도로 발전했다.
```
> code11

String phoneString; //타입이 바뀌어도 이름은 바뀌지 않는다.
```

클래스와 함수는 접두어가 핑료없을 정도로 작아야한다.
```
> code12

public class Part {
    private String m_dsc;
    
    void setName(String name) {
        m_dsc = name;
    }
}

public class Part {
    private String description;

    void setDescription(String description) {
        this.description = description;
    }
}
```

`code12`의 첫번째 클래스는 멤버 변수임을 알려주기위해 m_ 이라는 접두어를 붙혔다.<br>
요새는 IDE에서 변수를 색깔로 눈에 띄게 표시해주므로 두번째 클래스처럼 접두어를 붙힐 필요가 없다.
<br><br>

인터페이스 클래스 이름과 구현클래스 이름 중 하나를 인코딩 해야 한다면 구현클래스 이름을 인코딩 해라.
* Good
    * 인터페이스 클래스 : ShapeFactory
    * 구현 클래스 : ShapeFactoryImp
* Bad
    * 인터페이스 클래스 : IShapeFactory
    * 구현 클래스 : ShapeFactory
