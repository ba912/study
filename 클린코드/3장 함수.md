# 3장 함수

### 서론

* 의도를 분명히 표현하는 함수를 어떻게 구현할 수 있을까?
* 함수에 어떤 속석을 부여해야 처음 읽는 사람이 프로그램 내부를 직관적으로 파악할 수 있을까?

###### 목록 3-1 HtmlUtil.java
```
public static String testableHtml (PageData pageData, boolean includeSuiteSetup) throws Exception {
    WikiPage wikiPage = pageData.getWikiPage();
    StringBuffer buffer = new StringBuffer();
    if (pageData.hasAttribute("Test")) {
        if (includeSuiteSetup) {
            WikiPage suiteSetup = PageCrawlerImpl.getInheritedPage(SuiteResponder.SUITE_SETUP_NAME, wikiPage);
            if (suiteSetup != null) {
                WikiPagePath pagePath = suiteSetup.getPageCrawler().getFullPath(suiteSetup);
                String pagePathName = PathParser.render(pagePath);
                buffer.append("!include -setup .")
                    .append(pagePathName)
                    .append("\n");
            }
        }
        WikiPage setup = PageCrawlerImpl.getInheritedPage("SetUp", wikiPage);
        if (setup != null) {
            WikiPagePath setupPath = wikiPage.getPageCrawler().getFullPath(setup);
            String setupPathName = PathParser.render(setupPath);
            buffer.append("!include -setup .")
                .append(setupPathName)
                .append("\n");
        }
    }
    buffer.append(pageData.getContent());
    if (pageData.hasAttribute("Test")) {
        WikiPage teardown = PageCrawlerImpl.getInheritedPage("TearDown", wikiPage);
        if (teardown != null) {
            WikiPagePath tearDownPath = wikiPage.getPageCrawler().getFullPath(teardown);
            String tearDownPathName = PathParser.render(tearDownPath);
            buffer.append("\n")
                .append("!include -teardown .")
                .append(tearDownPathName)
                .append("\n");
        }
        if (includeSuiteSetup) {
            WikiPage suiteTeardown = PageCrawlerImpl.getInheritedPage(SuiteResponder.SUITE_TEARDOWN_NAME, wikiPage);
            if (suiteTeardown != null) {
                WikiPagePath pagePath = suiteTeardown.getPageCrawler().getFullPath(suiteTeardown);
                String pagePathName = PathParser.render(pagePath);
                buffer.append("!include -teardown .")
                    .append(pagePathName)
                    .append("\n");
            }
        }
    }
    pageData.setContent(buffer.toString());
    return pageData.getHtml();
}

```

* 추상화 수준이 다양하다.
* 하나의 함수 안에 너무 많은 코드가 작성되어있다.
* 두 겹으로 중첩된 if문은 이상한 플래그를 확인하고, 이상한 문자열을 사용하며, 이상한 함수를 호출한다.

위 코드에서 메서드 몇개를 추출하고, 이름 몇 개를 변경하고, 구조를 조금 변경하여 아래 코드로 바꾸었다.

###### 목록 3-2 HtmlUtil.java (리펙터링한 버전)

```
public static String renderPageWithSetupsAndTeardowns(PageData pageData, boolean isSuite) throws Exception {
    boolean isTestPage = pageData.hasAttribute("Test");
    if (isTestPage) {
        WikiPage testPage = pageData.getWikiPage();
        StringBuffer newPageContent = new StringBuffer();
        includeSetupPages(testPage, newPageContent, isSuite);
        newPageContent.append(pageData.getContent());
        includeTeardownPages(testPage, newPageContent, isSuite);
        pageData.setContent(newPageContent.toString());
    }
    return pageData.getHtml();
}
```

<br><br><br>
### # 작게만들어라!

함수를 만드는 첫번째 규칙은 '작게!'다.  
함수를 만드는 두번째 규칙은 '더 작게!'다.  

함수가 작을수록 더 좋다는 증거나 자료를 제시하기는 어렵지만, 100줄 넘는 함수보다 10줄의 함수가 더욱 파악하기 쉽다.

함수가 얼마나 짧아야 하느냐고?  
일반적으로 `목록 3-2`보다 짧아야 한다.

###### 목록 3-3 HtmlUtil.java (다시 리펙터링한 버전)

```
public static String renderPageWithSetupsAndTeardowns(PageData pageData, boolean isSuite) throws Exception {
    if (isTestPage(pageData)) {
        includeSetupAndTeardownPages(pageData, isSuite);
    }
    return pageData.getHtml();
}
```

`목록 3-2`는 `목록 3-3`으로 줄여야 마땅하다.

#### 블록과 들여쓰기

if문/else문/while문 등에 들어가는 블록은 한 줄이어야 한다.  
들여쓰기 수준은 1단이나 2단을 넘어서면 안된다.  
당연한 말이지만, 그래야 함수는 읽고 이해하기 쉬워진다.

<br><br><br>
### # 한 가지만 해라!

* 함수는 한 가지를 해야 한다.
* 그 한 가지를 잘 해야 한다.
* 그 한 가지만을 해야 한다.

`목록 3-1`은 여러가지를 처리한다. 버퍼를 생성하고, 페이지를 가져오고, 상속된 페이지를 검색하고, 경로를 랜더링하고, 불가사의한 문자열을 덧붙이고, HTML을 생성한다. `목록 3-3`은 한 가지만 처리한다. 설정 페이지와 해제 페이지를 테스트 페이지에 넣는다.

<br><br><br>
### # 함수 당 추상화 수준은 하나로!

함수가 확실히 '한 가지' 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다.  
###### `목록 3-1`의 `getHtml()`은 추상화 수준이 아주 높다.

한 함수 내에 여러 추상화 수준이 섞여있으면 해당 코드가 특정 기능의 근본 개념인지, 아니면 세부사항인지 읽는 사람이 헷갈린다.

<br><br><br>
### # 위에서 아래로 코드 읽기: 내려가기 규칙

* 코드는 위에서 아래로 이야기처럼 읽혀야 좋다.
* 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다.
* 핵심은 짧으면서도 '**한 가지**'만 하는 함수이다.

<br><br><br>
### # Switch문

switch문은 본질적으로 n가지를 처리하기 때문에 한가지 작업만 하는 switch문은 만들기 어렵다.  
swtich문을 저차원 클래스에 숨기고 절대로 반복하지 않는 방법은 있다.

###### 목록3-4 Payroll.java
```
public Money calculatePay(Employee e) throws InvalidEmployeeType {
    switch (e.type) {
        case COMMISSIONED:
            return calculateCommissionedPay(e);
        case HOURLY:
            return calculateHourlyPay(e);
        case SALARIED:
            return calculateSalariedPay(e);
        default:
            throw new InvalidEmployeeType(e.type);
    }
}
```
위 함수에는 몇가지 문제점들이 있다.

* 함수가 길다. 새 직원 유형을 추가하면 더 길어진다.
* 한가지 작업을 수행하지 않는다.
* 코드를 변경할 이유가 여러가지 이기 때문에 SRP(단일책임원칙)를 위반한다.
* 새 직원 유형을 추가할 때마다 코드를 변경하기 때문에 OCP(개방 폐쇄 원칙)를 위반된다.

###### 목록3-5 Employee and Factory

```
public abstract class Employee {
    public abstract boolean isPayday();
    public abstract Money calculatePay();
    public abstract void deliverPay(Money pay);
}

public interface EmployeeFactory {
    public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType;
}

public class EmployeeFactoryImpl implements EmployeeFactory {
    public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType {
        switch (r.type) {
            case COMMISSIONED:
                return new CommissionedEmployee(r);
            case HOURLY:
                return new HourlyEmployee(r);
            case SALARIED:
                return new SalariedEmploye(r);
            default:
                throw new InvalidEmployeeType(r.type);
        }
    }
}
```

* `목록 3-5`는 switch문을 추상 팩토리에 꽁꽁 숨긴다.  
* 팩토리는 switch 문을 사용해 적절한 employee 파생 클래스의 인스턴스를 생성한다.
* calculatePay, isPayday, deliverPay 등의 메서드는 Employee 인터페이스를 거쳐 호출된다.

<br><br><br>
### # 서술적인 이름을 사용하라!

* 코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수양한다면 깨끗한 코드라 불러도 되겠다.
* 길고 서술적인 이름이 짧고 어려운 이름보다 좋다.
* 이름을 붙일 때는 일관성이 있어야한다. 문제가 비슷하면 이야기를 순차적으로 풀어가기도 쉬워진다.
* ex) `includeSetupAndTeardownPages`, `includeSetupPages`, `includeSuiteSetupPage`

### # 함수 인수

* 함수에서 이상적인 인수 개수는 0개(무항)다. 다음은 1개(단항)고, 다음은 2개(이항)다. 3개는 가능한 피하는 편이 좋다. 4개 이상은 특별한 이유가 필요하다.
* 테스트 관점에서, 인수가 늘어나면 늘어날수록 조합이 복잡해져 테스트 하기가 어렵다.

#### 많이 쓰는 단항 형식

* 함수에 인수 1개를 넘기는 이유로 가장 흔한 경우는 두 가지다.
    * 인수에 질문을 던지는 경우 `boolean fileExists("MyFile")`
    * 인수를 뭔가로 변환해 결과를 반환하는 경우 `InputStream fileOpen("MyFile")`
* 다소 드물게 사용하지만 이벤트 함수도 단항 함수 형식으로 이루어져 있다. 이벤트 함수는 이벤트라는 사실이 코드에 명확히 드러나야한다.
    * ex) `void passwordAttemptFailedNtimes(int attempts)`
* 위 경우가 아니라면 단항 함수는 가급적 피한다.